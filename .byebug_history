continue
expect(Product.filter_by_title("TV").count).to eql 2
Product.filter_by_title("TV").count
Product.filter_by_title("TV")
expect(Product.filter_by_title("TV")).to have(2).items
Product.filter_by_title("TV")
continue
expect_json_sizes('user.product_ids', 0)
expect_json_sizes('user.product_ids' 0)
expect_json_sizes('user', product_ids: 0)
expect_json_keys('user', :product_ids, [])
expect_json_keys('user', :product_ids [])
expect_json_keys('user', product_ids: [])
expect_json_keys('user.product_ids', [])
expect_json_keys('user.product_ids', :array)
expect_json_keys('user', product_ids)
response.body
expect_json_keys('products.?', user: :object )
expect_json_keys('products.?', :user)
expect_json_keys('products.*', :user)
expect_json_keys('products.0', :user)
expect_json_keys('products', :user)
response.body
continue
expect_json("product.user.email", @product.user.email)
expect_json("user.email", @product.user.email)
response.body
continue
expect_json('errors', "Invalid email or password")
response.body
continue
response.body
continue
response.body
response
expect_json(email: @user.email)
continue
json_response
json_reponse
continue
json_response
continue
json_response
product_response = json_response[:product]
response.body
response
product_response
product_response = json_response[:product]
continue
render json: @user
response.body
response
products_response[:product]
products_response
products_response = json_response
json_response
continue
p respond_with Product.all
pp respond_with Product.all
respond_with Product.all
render json: Product.all
Product.all
Product
response.body
json_response
continue
json_response
result
response.body
response
response.body
continue
self.method(:current_user)
self
@current_user
current_us
current_user
User.find_by(auth_token: request.headers['Authorization'])
request.headers
request.header
request
user
continue
current_user
user
continue
current_user
user
continue
@current_user
@current_user ||= User.find_by(auth_token: request.headers['Authorization'])
User.find_by(auth_token: request.headers['Authorization'])
request.headers['Authorization']
request.headers
request.header
request
continue
authentication
authentication.current_user
authentication.current_user.auth_token
expect(authentication.current_user.auth_token).to eql @user.auth_token
@user.auth_token
@user
continue
sign_in @user
sign_in @user, store: false
@user
p @user
pp @user
@user
continue
user.valid_password? "sadfassferterbdsgsdfsdf34124123123s"
user.valid_password? "sadfassferterbdsgsdfsdfs"
user.valid_password? "sadfassferte rbdsgsdfsdfs"
user.valid_password?
user.valid_password? user_password.to_s
user.valid_password? user_password
user_password.to_s
user_password
user
User.first
User.count
continue
user.valid_password? user_password
user
params
user.password
user
user.valid_password? user_password
continue
user.valid_password? user_password
user_password
user
pp user
user
continue
response.body
response
continue
expect_json_keys('errors', [:email])
response.body
continue
expect_json(email: "new_email@gmail.com")
expect_json(:email, "new_email@gmail.com")
expect_json(email, "new_email@gmail.com")
expect_json(email: "new_email@gmail.com")
expect_json('user', email: "new_email@gmail.com")
response.body
response
user_response
continue
get :show, format: :json
get :show, id: @user.id, format: :json
get :show
get :show, id: @user.id, format: :json
:json
format:
format
continue
User.count
@user
continue
req.headers['Accept'].include?("application/vnd.sale-sale-an.v#{@version}")
@version
@default
@version
req.headers
req
continue
request
api_constraints_v1.matches?(request)
api_constraints_v1
continue
api_constraints_v1.matches?(request)
api_constraints_v1.matches?
request
api_constraints_v1
api_constraints
